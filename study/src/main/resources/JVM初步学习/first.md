**一、JVM内存的区域划分**
    1）程序计数器
    2）JAVA虚拟机栈
    3）本地方法栈
    4）JAVA堆
    5）方法区（包含常量池）

**二、对象创建的过程**
    1）当虚拟机遇到一个new的指令时，先去方法区（此处特指方法区）中寻找是否有目标类的符号引用，并检查此符号引号所代表的类是否已被加载、解析和初始化。
    如果尚没有，则需要先将类加载到方法区中（所以当我们在初始化一个实例时，总是静态变量和静态代码块先执行完毕，因为静态的属性在类加载的过程中，就
    已经一起装载到内存当中了）。
    2）此时开始内存的分配（对象所需要的内存大小基本在类加载完毕后，就可以确定），内存分配方法有如下两种：
           _No1.指针碰撞_
           此种分配方法要求内存分成两大块，一块是已使用的区域，另一块是未使用的区域，两者之间只需使用一个指针标记分开即可。如需要给对象开辟新的空间，只
           需将指针往空闲区域移动所需大小即可。
           _No2.空闲列表_
           内存不是规整的，已使用内存和未使用内存交错分布在内存当中。VM会维护一张表，上面记录着哪里还存在着空闲区域。当有新的需求时，VM会对照着空闲表来
           找出合适的空闲区域给对象。此分配方法要求虚拟机的GC有`压缩整理`功能。
       由于VM分配内存的动作有时频率会很高，可能会有多个线程同时工作，那这时候使用“指针碰撞”的分配方法，在移动指针的位置时，由于多个线程操作的都是同一
       个指针，线程安全的问题一下子就暴露出来了。给内存分配的动作加上“同步”的限制，或许是个方法，但这样会降低内存分配的效率，标记指针只有一个，线程再多
       也只能排队等待。另一个方法则是使用“`本地线程分配缓冲TLAB(Thread Local Allocation Buffer)`”，VM事先会给执行分配的线程们分配一小块内存（TLAB），当
       有分配请求时，线程们会使用自己的缓冲内存。当线程使用完这些缓冲，VM重新给它们分配空间时，会加上同步锁。
    3）执行完new指令后，会接着执行<init>指令，将对象中的变量初始化为代码中命令的形式。
       
       
    